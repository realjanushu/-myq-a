 #### 以下关于Java语言处理描述正确的有?  
  * [ ]A.throw关键字可以在方法上声明该方法要抛出
  * [ ]B.throw用于抛出异常对象  
  * [x]C.try是用于检测被包住的语句块是否出现异常  
  * [x]D.finally语句块是不管有没有出现异常都要执行的内容
  * [ ]E.在try块中不可以抛出异常  
> **Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。  
throw用于抛出异常。  
throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。  
try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。  
cacth用于捕获从try中抛出的异常并作出处理。  
finally语句块是不管有没有出现异常都要执行的内容。**

#### 下列代码的输出结果是`__`  
```
boolean b = true?false:true==true?false:true;
System.out.println(b);
 ```
* [ ]A.true
* [x]B.false
* [ ]C.null
* [ ]D.空字符串
> ** ==  优先级高于 三目运算符，先判断   true == true，此时返回为true,  
这时表达式为   boolean b = true?false:true?false:true  
此时三目运算符从右向左执行,true?false:true，返回false  
这时表达式为  boolean b = true?false:false;  
结果为：boolean b = false**

#### given the following code:
    ```Java
      public class Test{
        private static Boolean methodB(int k){
          j += k;
          return true;
        }
        public static void methodA(int i){
          b = i < 10 | methodB(4);
          b = i < 10 || methodB(8);
        }
        public static void main(String[] args){
          methodA(0);
          System.out.println(j);
        }
      }
    ```
  #### What is the result?
  * [ ]A.The program prints "0"
  * [x]B.the program prints "4"
  * [ ]C.the program prints "8"
  * [ ]D.the program prints "12"
  * [ ]E.The code does not complete.
  >**选 B  
  在main函数中先调用methodA（0）  
  在methodA中，第二行 **

  >```Java
  b = i < 10 | methodB(4); //中间为与计算符，执行完methodB(4)后，j = 4
  ```
  **methodA中，第三行**
  ```Java
  b = i < 10 || methodB(8);//中间为或计算符，因为i < 10 已成立，不需要后续计算  
  ```
  **所以最后结果输出为4 **

#### What will printed when you execute the following code?  
```Java
  class C{
    c(){
      System.out.println("C");
    }
  }
  class A{
    C c = new C();
    A(){
      this("A");
      System.out.print("A");
    }
    A(String s){
      System.out.print(s);
    }
  }
  class Test extends A{
    Test(){
      super("B");
      System.out.println("B");
    }
    public static void main(String[] args){
      new Test();
    }
  }  
```  
* [ ]A.BB
* [x]B.CBB
* [ ]C.BAB
* [ ]D.None of above

>**初始化过程是这样的：   
1.首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；  
2.然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；  
3.其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法；  
4.最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法；   **

>**（1）初始化父类的普通成员变量和代码块，执行 C c = new C(); 输出C   
（2）super("B"); 表示调用父类的构造方法，不调用父类的无参构造函数，输出B   
（3） System.out.print("B"); 所以输出CBB **

#### 有关hashMap跟hashTable的区别，说法正确的是？
* [x]A.hashMap和Hashtable都实现了Map接口
* [x]B.HashMap是非synchronized，而是Hashtable是synchronized
* [x]C.hashTabl使用Enumeration，HashMap使用Iterator
* [x]D.Hashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与替代求模  

#### Given:
```Java
  //point X
  public class Foo{
    public static void main(String[] args) throws Exception{
      PrintWriter out = new PrintWriter(
      new java.io.OutputStreamWirter(System.out),true);
      out.printIn("hello");
    }
  }
```
>**答案：A  
java中没有include关键字，导包用import  
由于代码中使用了printWriter 类，所以要导入此类Import java.io.PrintWriter;  **
